from pathlib import Path

from vulnhuntr.enums import *

# test_suite is an array of dictionary, each dictionary holding the required config to run xvulnhuntr
test_suite = []

###### first mock: C# BloodBankManagementSystem
# https://github.com/vijaythapa333/BloodBankManagementSystem

test_suite.append({})

test_suite[0]["root"] = Path.cwd() / "tests/c#/BloodBankManagementSystem/"
test_suite[0]["analyze"] = Path.cwd() / "tests/c#/BloodBankManagementSystem/BloodBankManagementSystem/Program.cs"
test_suite[0]["mock"] = True
test_suite[0]["langtype"] = LanguageType.CSHARP
test_suite[0]["reporting"] = True # conditionally view verbose reporting logs

mock_texts = {}

mock_texts[PromptStep.SUMMARY] = """<summary>\nThis is a C# desktop application for managing blood bank donor information. From a security perspective, the attack surface appears minimal as it's a standalone desktop app that primarily interfaces with a local MS SQL Server database. No explicit network-facing components or remote APIs are mentioned in the documentation. The key features (user management, authentication, donor management, and dashboard) appear to be completely local. The only external connection mentioned is the database connection string configuration, which typically connects to a local or network SQL Server instance.\n</summary>"""
mock_texts[PromptStep.INITIAL_ANALYSIS] = []
mock_texts[PromptStep.INITIAL_ANALYSIS].append("""First examining Program.cs which shows this is a WinForms app starting with frmSplash. 2.Need to examine frmSplash to identify potential remote entry points and risky function calls. 3.Since this appears to be a desktop app connecting to a database, need to check database connection initialization in frmSplash. 4.Also need to check if frmSplash loads any remote resources like images or config files. 5.Looking for any network listeners, remote API calls or web functionality but need more context.\",\n    \"analysis\": \"Initial analysis of Program.cs shows this is a Windows Forms desktop application that starts with a splash screen form (frmSplash). While desktop apps typically have a limited remote attack surface, there could be vulnerabilities if the app loads remote resources, connects to external services, or processes network data. Need to examine frmSplash to identify potential remote entry points and dangerous function calls.\",\n    \"poc\": \"None - Need more context about frmSplash implementation to develop PoC\",\n    \"confidence_score\": 1,\n    \"vulnerability_types\": [\"SQLI\", \"LFI\"],\n    \"context_code\": [\n        {\n            \"name\": \"frmSplash\",\n            \"reason\": \"Need to examine the splash screen form for remote resource loading, database connections, and potential network functionality\",\n            \"code_line\": \"Application.Run(new frmSplash());\"\n        }\n    ]\n}""")
mock_texts[PromptStep.SECONDARY_ANALYSIS] = {}
mock_texts[PromptStep.SECONDARY_ANALYSIS][VulnType.SQLI] = [
    """Examining Program.cs - This is the main entry point for a Windows Forms application. 2.Application.Run(new frmSplash()) launches a splash screen form. 3.Need to examine frmSplash and related forms for input handling and database operations. 4.No direct evidence of SQL operations or user input in Program.cs, but since this is a blood bank management system mentioned in the readme, database interactions are likely. 5.Need to examine frmSplash class to follow the code execution path and find potential remote input handlers.\",\n    \"analysis\": \"The initial analysis of Program.cs reveals this is a Windows Forms desktop application. While the readme suggests database connectivity, there is no immediate evidence of remotely exploitable vulnerabilities in the main program entry point. To properly assess potential SQL injection and other vulnerabilities, we need to examine the frmSplash class and any subsequent forms or classes it may load that handle user input and database operations.\",\n    \"poc\": \"None\",\n    \"confidence_score\": 0,\n    \"vulnerability_types\": [],\n    \"context_code\": [\n        {\n            \"name\": \"frmSplash\",\n            \"reason\": \"This is the initial form loaded by the application. Need to examine it for potential vulnerabilities and to follow the application flow.\",\n            \"code_line\": \"Application.Run(new frmSplash());\"\n        }\n    ]\n}""",
    """Reviewed Program.cs and frmSplash.cs to understand application flow. 2.Program.cs launches frmSplash as main entry point. 3.frmSplash runs a timer animation then launches frmLogin form. 4.No direct evidence of network listeners or remote input processing yet. 5.Need to examine frmLogin and any subsequent forms that handle user authentication and database operations to identify potential SQLI entry points.\",    \n    \"analysis\": \"Based on the available code, this is a Windows Forms desktop application that starts with a splash screen (frmSplash) which then loads a login form (frmLogin). While the README mentions database connectivity, the current code path shows no evidence of network listening capabilities or remote input processing. To properly assess for SQL injection and other remote vulnerabilities, we need to examine the login form and any database interaction code it triggers.\",\n    \"poc\": \"None\",\n    \"confidence_score\": 0,\n    \"vulnerability_types\": [],\n    \"context_code\": [\n        {\n            \"name\": \"frmLogin\",\n            \"reason\": \"Need to examine the login form code to identify potential SQL injection vectors in authentication logic\",\n            \"code_line\": \"frmLogin login = new frmLogin();\"\n        }\n    ]\n}""",
    """Traced code flow: Program.cs -> frmSplash.cs -> frmLogin.cs. 2.Identified potential SQLI entry point in frmLogin.cs where user input from txtUsername.Text and txtPassword.Text flows into loginDAL.loginCheck(). 3.Need to analyze loginDAL.loginCheck() to confirm if user input is directly concatenated into SQL query. 4.Current code shows local Windows Forms desktop app with no direct network listening capabilities. 5.Additional context needed to confirm SQLI: loginBLL class for any input validation and loginDAL class to see how SQL queries are constructed.\",\n    \"analysis\": \"Initial code analysis reveals a potential SQL injection vulnerability in the login form where username and password from text inputs are passed unchecked to loginDAL.loginCheck(). However, full vulnerability confirmation requires examination of the loginDAL and loginBLL classes to understand input validation and SQL query construction. The application appears to be a local Windows Forms app with no direct network attack surface, which would typically limit remote exploitation. However, any SQL injection vulnerability could potentially be exploited if the application were exposed via remoting or if the login form were modified to accept remote input in a future version.\",\n    \"poc\": \"None - Cannot construct reliable PoC without seeing SQL query construction in loginDAL class\",\n    \"confidence_score\": 3,\n    \"vulnerability_types\": [\"SQLI\"],\n    \"context_code\": [\n        {\n            \"name\": \"loginBLL\",\n            \"reason\": \"Need to examine any input validation or sanitization of username/password before database operations\",\n            \"code_line\": \"loginBLL l = new loginBLL();\"\n        },\n        {\n            \"name\": \"loginDAL\",\n            \"reason\": \"Need to examine SQL query construction in loginCheck method to confirm SQLI vulnerability\",\n            \"code_line\": \"bool isSuccess = dal.loginCheck(l);\"\n        }\n    ]\n}""",
    """Analyzed Program.cs - Windows Forms app entry point launching frmSplash. 2.Reviewed frmSplash - Simple splash screen that launches frmLogin. 3.Examined frmLogin - Takes username/password input and passes to loginDAL.loginCheck() through loginBLL object. 4.Analyzed loginBLL - Simple DTO with username/password properties. 5.Reviewed loginDAL.loginCheck() - Found SQL injection vulnerability: SQL query constructed with user input parameters from form, but using SqlParameter.AddWithValue which properly parameterizes the query preventing SQL injection. 6.Checked for other attack vectors - No network listeners or remote entry points found, purely local Windows Forms app. 7.Evaluated overall risk - While SQL queries use parameterization correctly preventing injection, the local-only nature of the app means no remote exploitation vectors exist.\",\n    \"analysis\": \"The application is a standalone Windows Forms blood bank management system with login functionality. While it interfaces with a SQL Server database, all database queries are properly parameterized using SqlParameter.AddWithValue() in loginDAL.loginCheck(), preventing SQL injection. The application has no network-facing components or APIs - it runs entirely locally on the user's machine. Without any remote entry points or network listeners, there are no remotely exploitable vulnerabilities. All user input comes from local Windows Forms controls and proper SQL parameterization is used throughout. The only identified database interaction uses parameterized queries, eliminating SQL injection risk even in a local context.\",\n    \"poc\": \"None - No remotely exploitable vulnerabilities identified as the application has no network attack surface.\",\n    \"confidence_score\": 9,\n    \"vulnerability_types\": [],\n    \"context_code\": []\n}"""
]
mock_texts[PromptStep.SECONDARY_ANALYSIS][VulnType.LFI] = [
    """Reviewed initial Program.cs file which shows a Windows Forms desktop application entry point. 2.Application flow starts with frmSplash form. 3.Need to analyze frmSplash for potential file operations and user input handling. 4.As this is a Windows Forms app, primary focus will be on form UI components and event handlers. 5.Requesting frmSplash class code to analyze user input handling and any file operations.\",\n    \"analysis\": \"Initial analysis of Program.cs reveals a Windows Forms desktop application with a splash screen entry point. While this is a desktop app, it's important to analyze the frmSplash form for potential network-facing components or remote file operations that could lead to LFI vulnerabilities. Need to examine frmSplash implementation to determine if there are any remote attack vectors.\",\n    \"poc\": \"None - insufficient code context to determine exploitability\",\n    \"confidence_score\": 0,\n    \"vulnerability_types\": [\"LFI\"],\n    \"context_code\": [\n        {\n            \"name\": \"frmSplash\",\n            \"reason\": \"Need to analyze the splash screen form implementation for potential file operations and remote input handling\",\n            \"code_line\": \"Application.Run(new frmSplash());\"\n        }\n    ]\n}""",
    """Reviewed Program.cs showing Windows Forms desktop app entry point. 2.Examined frmSplash form showing simple splash screen with timer animation. 3.Need to check frmLogin for potential network functionality since it's loaded after splash screen. 4.No direct file operations or network calls found in current code. 5.Need to analyze frmLogin implementation to continue vulnerability assessment.\",    \"analysis\": \"Initial analysis of Program.cs and frmSplash shows a Windows Forms desktop application with a basic splash screen animation that transitions to a login form. So far, no remotely exploitable vulnerabilities have been identified as there are no network-facing components or file operations in the reviewed code. To complete the security assessment, particularly for potential LFI vulnerabilities, we need to examine the frmLogin implementation as it may contain database connections, file operations, or network functionality that could introduce security risks.\",    \"poc\": \"None\",    \"confidence_score\": 0,    \"vulnerability_types\": [],    \"context_code\": [        {            \"name\": \"frmLogin\",            \"reason\": \"Login form may contain file operations, network calls, or database connections that could introduce LFI vulnerabilities\",            \"code_line\": \"frmLogin login = new frmLogin();\"        }    ]}""",
    """Reviewed Program.cs - Entry point for WinForms app showing splash screen. 2.Analyzed frmSplash - Simple splash screen with timer that transitions to login form. No file or network ops. 3.Examined frmLogin - Basic login form checking credentials via loginBLL/loginDAL classes. 4.Need to examine loginDAL.loginCheck() method to understand credential validation and potential LFI vulnerabilities through config files or DB connections. 5.Also need loginBLL class to see any file operations in business logic layer.\",    \n\"analysis\": \"Initial review shows a desktop WinForms application with a standard login flow. The main security-critical path is in the credential validation through loginDAL.loginCheck(), but we don't yet have visibility into its implementation. File operations or unsafe path handling in these classes could introduce LFI vulnerabilities if they involve user-controlled input. However, the application appears to be a standalone desktop app with no obvious remote attack vectors, limiting the likelihood of remote exploitation.\",\n\"poc\": \"None\",\n\"confidence_score\": 2,\n\"vulnerability_types\": [\"LFI\"],\n\"context_code\": [\n    {\n        \"name\": \"loginDAL\",\n        \"reason\": \"Need to examine credential validation and potential file operations in data access layer\",\n        \"code_line\": \"loginDAL dal = new loginDAL();\"\n    },\n    {\n        \"name\": \"loginBLL\",\n        \"reason\": \"Need to check business logic layer for file operations or path handling\",\n        \"code_line\": \"loginBLL l = new loginBLL();\"\n    }\n]}""",
    """Analyzing Program.cs - only shows standard WinForms startup code, launching frmSplash. 2.Checking frmSplash - simple splash screen that auto-transitions to frmLogin after animation. 3.Examining frmLogin - handles user authentication but no file operations. 4.Reviewing loginDAL - uses parameterized SQL queries for auth, no file operations. 5.Looking at loginBLL - simple model class with username/password properties. 6.No file operations or path handling found in any provided code. 7.Application appears to be a standard desktop WinForms app with no exposed network endpoints or remote attack surface. 8.Login validation uses parameterized queries which prevents SQL injection. 9.No user-controlled file paths or names found that could lead to LFI.\",\n    \"analysis\": \"After reviewing the provided code, I found no evidence of Local File Inclusion vulnerabilities. The application is a desktop WinForms program with no exposed network endpoints or remote attack surface. The only external interaction is with a local SQL Server database, which uses parameterized queries for credential validation. There are no file operations or path handling functions that accept user input. The application follows a standard WinForms architecture with form-to-form navigation and local authentication.\",\n    \"poc\": \"None - No LFI vulnerability discovered\",\n    \"confidence_score\": 3,\n    \"vulnerability_types\": [],\n    \"context_code\": [\n        {\n            \"name\": \"frmHome\",\n            \"reason\": \"Need to check if home form contains any file operations or path handling that could lead to LFI\",\n            \"code_line\": \"frmHome home = new frmHome();\"\n        }\n    ]\n}""",
    """Analyzed Program.cs - main entry point that launches splash screen. 2.Analyzed frmSplash - Simple form with timer that transitions to login form. 3.Analyzed frmLogin - Basic login form with username/password validation. 4.Analyzed loginDAL - Handles database authentication with parameterized queries. 5.Analyzed loginBLL - Simple user model class. 6.Analyzed frmHome - Main application interface with no file operations. 7.No remote network listeners or exposed endpoints found. 8.No file path handling or inclusion functions identified. 9.No user-controlled file operations discovered.\",\n    \"analysis\": \"After thorough analysis of the provided code, I found no viable Local File Inclusion vulnerabilities. The application is a standard C# WinForms desktop program without any network-exposed components that could enable remote exploitation. The only external interaction is with a local SQL Server database using parameterized queries. The application follows typical desktop application patterns with form-to-form navigation and does not implement any file inclusion or path handling functionality that accepts user input. While the application does read a connection string from configuration, this is handled by the .NET framework's configuration system and is not exposed to remote user input.\",\n    \"poc\": \"None - No LFI vulnerability identified\",\n    \"confidence_score\": 0,\n    \"vulnerability_types\": [],\n    \"context_code\": []\n}"""
]

test_suite[0]["mock"] = mock_texts

##### second mock: python indico
# https://github.com/indico/indico

test_suite.append({})
test_suite[1]["root"] = Path.cwd() / "tests/python/indico-master/"
test_suite[1]["analyze"] = Path.cwd() / "tests/python/indico-master/indico/cli/core.py"
test_suite[1]["mock"] = True
test_suite[1]["langtype"] = LanguageType.PYTHON
test_suite[1]["reporting"] = True # conditionally view verbose reporting logs

mock_texts = {}

mock_texts[PromptStep.SUMMARY] = """<summary>\nIndico is an open-source event management system developed at CERN that runs as a web-based application. Key security-relevant aspects:\n\nMain purpose:\n- Web-based conference/event management platform\n\nNetwork attack surfaces:\n- Full web interface for users and administrators\n- Payment system integrations\n- Video conferencing system integrations\n- Registration form system\n- User authentication system\n\nKey networked features:\n- Conference organization workflows\n- Room booking interface\n- Paper/abstract submission and review systems\n- Badge printing system\n- Content management system for events\n\nThe application is browser-based and requires modern browser support, indicating extensive client-side functionality alongside its server-side components.\n</summary>"""
mock_texts[PromptStep.INITIAL_ANALYSIS] = []
mock_texts[PromptStep.INITIAL_ANALYSIS].append("""Identified core CLI command endpoints in cli.py but need to trace RCE paths in eval shells. 2.Found potential RCE via debug shell/console (/console) through enable_evalex flag.3.Shell access on line 187 - shell_cmd allows running shell with request context. 4.Need to inspect shell_cmd implementation 5.Evalex debugger shell whitelisting via --evalex-from may be bypassable. 6.Debugger console reachable via /console when enable_evalex=True. 7.Need to see request handling of evalex debugger shell.\",\n    \"analysis\": \"The code contains two concerning points of RCE: 1) The Werkzeug debugger's interactive Python shell that can be enabled via --enable-evalex flag and accessed via /console endpoint or tracebacks. While there is IP whitelisting via --evalex-from, this could potentially be bypassed depending on implementation. 2) An interactive shell via shell_cmd that can run with a request context. Both of these could allow remote code execution if not properly secured. The debug shell is particularly concerning as it's web accessible when enabled.\",\n    \"poc\": \"1. Enable debug shell: indico run --enable-evalex --evalex-from=127.0.0.1\\n2. Access /console endpoint or trigger error to get traceback shell\\n3. Enter arbitrary Python code to execute on server\\nNote: Full PoC requires seeing implementation of evalex whitelisting and shell_cmd\",\n    \"confidence_score\": 6,\n    \"vulnerability_types\": [\"RCE\"],\n    \"context_code\": [\n        {\n            \"name\": \"shell_cmd\",\n            \"reason\": \"Need to analyze shell command implementation for RCE vectors\",\n            \"code_line\": \"from .shell import shell_cmd\"\n        },\n        {\n            \"name\": \"indico.cli.devserver.run_cmd\",\n            \"reason\": \"Need to inspect debug server configuration and evalex handling\",\n            \"code_line\": \"from indico.cli.devserver import run_cmd\"\n        }\n    ]\n}""")
mock_texts[PromptStep.SECONDARY_ANALYSIS] = {}
mock_texts[PromptStep.SECONDARY_ANALYSIS][VulnType.RCE] = [
"""Examining core.py for RCE vectors. 2.Found several CLI commands including cleanup, shell, setup, etc. 3.Most concerning is shell command with --enable-evalex option that enables werkzeug debugger console. 4.Evalex-from allows restricting access by IP but defaults to allowing anyone. 5.Need to examine devserver.py to understand run_cmd implementation and see if werkzeug debugger is enabled by default or secure. 6.The debug console, if enabled, provides a Python REPL that can execute arbitrary code. 7.Requesting devserver run_cmd code to confirm vulnerability chain.\",    \"analysis\": \"The most concerning issue identified is the werkzeug debugger console accessed via the --enable-evalex flag. This exposes a Python REPL endpoint that allows arbitrary code execution. While this is gated behind a CLI flag, lack of proper IP restrictions by default is dangerous if enabled in a semi-public environment. However, I need to examine the run_cmd implementation to confirm if there are additional security controls or if the debugger is enabled by default.\",    \"poc\": \"None - Need run_cmd implementation to provide valid PoC and confirm vulnerability chain.\",    \"confidence_score\": 4,    \"vulnerability_types\": [\"RCE\"],    \"context_code\": [        {            \"name\": \"indico.cli.devserver.run_cmd\",            \"reason\": \"Need to examine run_cmd implementation to confirm werkzeug debugger setup and default security controls\",            \"code_line\": \"from indico.cli.devserver import run_cmd\"        }    ]}""",
"""Reviewing core.py and devserver.py for RCE paths. 2.Found --enable-evalex flag in CLI which enables Werkzeug debugger console. 3.Need to analyze run_server() to understand if there are additional security controls around the debugger. 4.Observed --evalex-from parameter which restricts debugger access by IP, but defaults to open if not specified. 5.Critical to analyze run_server() implementation to confirm if debugger is secured by default. 6.Current code path shows cli -> run_cmd -> run_server, but need run_server implementation.\",    \"analysis\": \"The code exposes a potential Remote Code Execution vulnerability through the Werkzeug debugger console enabled via --enable-evalex flag. While this requires explicitly enabling the flag, the implementation allows unrestricted access to the Python REPL by default since the --evalex-from parameter is optional. However, to confirm the full exploitability and default security controls, I need to analyze the run_server() implementation.\",    \"poc\": \"Currently incomplete without run_server() implementation. Initial potential attack path: 1. Start server with --enable-evalex flag 2. Access /console endpoint 3. Execute arbitrary Python code via REPL. Need run_server() code to confirm lack of additional security controls.\",    \"confidence_score\": 5,    \"vulnerability_types\": [\"RCE\"],    \"context_code\": [{        \"name\": \"run_server\",        \"reason\": \"Need to analyze the implementation to confirm debugger security controls and default settings\",        \"code_line\": \"run_server(info, **kwargs)\"    }]}""",
"""Analyzed core.py which exposes CLI commands. 2.Found run command that starts dev server. 3.Traced run_cmd to run_server in devserver.py. 4.Discovered --enable-evalex flag that enables Werkzeug debugger console. 5.Analyzed evalex_whitelist logic - defaults to True when --evalex-from not provided, making console accessible to all clients. 6.Traced call chain showing server starts with eval console at /console endpoint. 7.Confirmed evalex setting flows through to _make_wsgi_app() call. 8.Need to analyze _make_wsgi_app to verify final settings. 9.Risk verified since console provides full Python REPL access if enabled.\",\n\n    \"analysis\": \"The code contains a critical RCE vulnerability through the Werkzeug debugger console that can be enabled via the --enable-evalex flag. When enabled without specifying --evalex-from IPs, the console is accessible to all clients (evalex_whitelist=True). The console provides unrestricted access to a Python REPL at the /console endpoint, allowing arbitrary code execution. While this requires explicitly enabling the flag, the default implementation allows unrestricted access since --evalex-from is optional. This is particularly dangerous in development environments where developers may enable the flag for debugging. The vulnerability exists in the run_server() function where evalex_whitelist is set to True by default if no IPs are specified. Need to analyze _make_wsgi_app() to confirm final security controls but current evidence shows high exploitability.\",\n\n    \"poc\": \"1. Start server with debug console enabled: indico run --enable-evalex\\n2. Access /console endpoint from any IP\\n3. Execute arbitrary Python code via console, e.g.:\\n   import os\\n   os.system('id')\",\n\n    \"confidence_score\": 8,\n\n    \"vulnerability_types\": [\"RCE\"],\n\n    \"context_code\": [\n        {\n            \"name\": \"_make_wsgi_app\",\n            \"reason\": \"Need to verify if any additional security controls are applied to the eval console\",\n            \"code_line\": \"app = _make_wsgi_app(info, url, evalex_whitelist, proxy)\"\n        }\n    ]\n}""",
"""The code analysis focuses on the Werkzeug debugger console vulnerability identified in previous analysis, continuing investigation of the call chain from run_server to _make_wsgi_app and DebuggedIndico. 2.From the code, the debugger console (RCE interface) is enabled when --enable-evalex flag is used. Most dangerous case is when evalex_whitelist=True (no IPs specified). 3.Following the code path: CLI run command -> run_cmd -> run_server -> _make_wsgi_app where DebuggedIndico is initialized with evalex_whitelist. 4.The code shows the debugger console is accessible at /console endpoint when enabled, providing a web-accessible Python REPL. 5.Need to analyze DebuggedIndico class implementation to determine final security controls and confirm remote exploitability.\",    \"analysis\": \"The code contains a critical RCE vulnerability through the Werkzeug debugger console when the --enable-evalex flag is used without --evalex-from IP restrictions. The vulnerability allows remote attackers to execute arbitrary Python code through the /console endpoint. The vulnerability is particularly dangerous because: 1) When no IPs are specified, access is granted to all clients (evalex_whitelist=True) 2) The console endpoint provides unrestricted access to a Python REPL 3) This exists in a development server context where the flag may be enabled for debugging. The code path shows this vulnerability is remotely exploitable through the web interface once enabled. While this requires explicit activation via CLI flag, the default implementation with no IP restrictions creates a severe security risk.\",    \"poc\": \"1. Start the dev server with debugger console enabled: indico run --enable-evalex\\n2. Access the /console endpoint from any IP\\n3. Execute arbitrary Python code via the REPL, e.g.:\\n   >>> import os\\n   >>> os.system('id')\",    \"confidence_score\": 9,    \"vulnerability_types\": [\"RCE\"],    \"context_code\": [{\"name\": \"DebuggedIndico\", \"reason\": \"Need to analyze the debugger console implementation and any security controls\", \"code_line\": \"app = DebuggedIndico(app, evalex_whitelist)\"}]}""",
"""Analyzing core.py and provided context code for RCE vectors. 2.Found critical RCE through Werkzeug debugger console with --enable-evalex flag. 3.Traced execution path: core.py run() -> devserver.py run_cmd() -> run_server() -> _make_wsgi_app() -> DebuggedIndico. 4.Key vulnerability components: a)evalex_whitelist default is True when --enable-evalex used without --evalex-from b)DebuggedIndico inherits from Werkzeug's DebuggedApplication providing Python REPL c)No input validation or sandbox restrictions on executed code 5.Remote exploitation possible through /console endpoint when debugger enabled 6.Confidence high (9/10) as full code path is visible from CLI arg handling through to debugger activation. 7.Previous analysis confirms findings.\",\n    \"analysis\": \"The code contains a critical Remote Code Execution vulnerability through Werkzeug's debugger console, enabled via the --enable-evalex CLI flag. When enabled without IP restrictions (--evalex-from), the debugger console is accessible to all remote clients at the /console endpoint. This provides unrestricted access to a Python REPL where arbitrary code can be executed in the application context. The vulnerability is confirmed through code analysis showing: 1) CLI flag processing in core.py run() command 2) Debugger activation in devserver.py through DebuggedIndico class 3) evalex_whitelist defaulting to True when no IPs specified 4) No code execution restrictions or sandboxing in the debugger console. While this requires explicit activation of the debug flag, the default implementation with no IP restrictions creates a severe security risk in development environments.\",\n    \"poc\": \"1. Start server with debug console: indico run --enable-evalex\\n2. Access /console endpoint from any IP\\n3. Execute arbitrary Python code via debugger console, e.g.:\\n   >>> import os\\n   >>> os.system('id')\\n   >>> __import__('subprocess').check_output(['cat','/etc/passwd'])\",\n    \"confidence_score\": 9,\n    \"vulnerability_types\": [\"RCE\"],\n    \"context_code\": []\n}"""
]

test_suite[1]["mock"] = mock_texts

##### third mock, automatically generated from stored responses

# /<project>/mock_responses/<timestamp>/
# response0 (summary)
# response1 (initial analysis)
# response2_VULN_TYPE
# responseN_VULN_TYPE
#
# A timestamp (milliseconds) is used as filename to preserve the response order
# e.g.
# 1741769032593 (summary)
# 1741769032612 (initial analysis)
# 1741769032621_SQLI (secondary analysis SQLI)
# 1741769033096_SQLI
# 1741769033424_SQLI
# 1741769034051_SQLI
# 1741769034056_LFI (secondary analysis LFI)
# 1741769034342_LFI
# 1741769034647_LFI
# 1741769035280_LFI
# 1741769035548_LFI

def get_mocks_from_responses(directory: str) -> dict:
    mock_texts = {}
    mock_texts[PromptStep.INITIAL_ANALYSIS] = []
    mock_texts[PromptStep.SECONDARY_ANALYSIS] = {}
    for vuln_type in VulnType:
        mock_texts[PromptStep.SECONDARY_ANALYSIS][vuln_type] = []

    directory_path = Path(directory)

    files = sorted(directory_path.iterdir(), key=lambda f: f.name)

    i=0
    for file in files:
        if file.is_file():
            with file.open("r", encoding="utf-8") as f:
                response_content = f.read()

                response_type = str(file.name).split("_") 
                if i==0:
                    mock_texts[PromptStep.SUMMARY] = response_content 
                elif len(response_type) == 1: # filename: <timestamp> without '_', hence this is an initial_analysis
                    mock_texts[PromptStep.INITIAL_ANALYSIS].append(response_content)
                else:
                    vuln_type = response_type[1] # filename: <timestamp>_<vuln_type>
                    mock_texts[PromptStep.SECONDARY_ANALYSIS][VulnType(vuln_type)].append(response_content)
        i=i+1

    return mock_texts 

# third mock, same as first mock (BloodBankManagementSystem), however mock responses are created based on responses saved to file with -w option
test_suite.append({})
test_suite[2]["root"] = Path.cwd() / "tests/c#/BloodBankManagementSystem/"
test_suite[2]["analyze"] = Path.cwd() / "tests/c#/BloodBankManagementSystem/BloodBankManagementSystem/Program.cs"
test_suite[2]["mock"] = True
test_suite[2]["langtype"] = LanguageType.CSHARP
test_suite[2]["reporting"] = True # conditionally view verbose reporting logs

mock_texts = get_mocks_from_responses("tests/c#/BloodBankManagementSystem/mock_responses/1741769032/")

test_suite[2]["mock"] = mock_texts

# fourth mock, go lang go-webapp-sample
# https://github.com/ybkuroki/go-webapp-sample
test_suite.append({})
test_suite[3]["root"] = Path.cwd() / "tests/go/go-webapp-sample-master"
test_suite[3]["analyze"] = Path.cwd() / "tests/go/go-webapp-sample-master/main.go"
test_suite[3]["mock"] = True
test_suite[3]["langtype"] = LanguageType.GO
test_suite[3]["reporting"] = True # conditionally view verbose reporting logs
test_suite[3]["iterations_in_secondary_analysis"] = 6

mock_texts = get_mocks_from_responses("tests/go/go-webapp-sample-master/mock_responses/1742400550/")

test_suite[3]["mock"] = mock_texts

long_run_tests = False # some test suites take quite some time, run them when required (e.g. major changes)
# fifth mock, java
# https://github.com/raus376/OnlineTripManagementSystemApp/tree/main
if long_run_tests:
    test_suite.append({})
    test_suite[4]["root"] = Path.cwd() / "tests/java/OnlineTripManagementSystemApp-main/"
    test_suite[4]["mock"] = True
    test_suite[4]["langtype"] = LanguageType.JAVA
    test_suite[4]["reporting"] = True # conditionally view verbose reporting logs

    mock_texts = get_mocks_from_responses("tests/java/OnlineTripManagementSystemApp-main/mock_responses/1742467377/")

    test_suite[4]["mock"] = mock_texts